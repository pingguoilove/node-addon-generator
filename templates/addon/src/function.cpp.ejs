Handle<Value> <%- obj.name %>::<%- f.cppName %>(const Arguments& args) {
  HandleScope scope;

  REQ_OBJECT_ARG(0, options);
  REQ_FUN_ARG(1, callback);

  <%- obj.name %>* self = ObjectWrap::Unwrap<<%- obj.name %>>(args.This());
  <%- f.cppName %>Baton* baton = new <%- f.cppName %>Baton(self, self->m_environment, &callback);

  OBJ_GET_STRING(options, "hostname", baton->hostname);
  OBJ_GET_STRING(options, "user", baton->user);
  OBJ_GET_STRING(options, "password", baton->password);
  OBJ_GET_STRING(options, "database", baton->database);
  OBJ_GET_NUMBER(options, "port", baton->port, 1521);
  OBJ_GET_STRING(options, "tns", baton->tns);

  self->Ref();

  uv_work_t* req = new uv_work_t();
  req->data = baton;
  uv_queue_work(uv_default_loop(), req, <%- f.cppName %>Async, (uv_after_work_cb)After<%- f.cppName %>);

  return scope.Close(Undefined());
}

void <%- obj.name %>::<%- f.cppName %>Async(uv_work_t* req) {
  <%- f.cppName %>Baton* baton = static_cast<<%- f.cppName %>Baton*>(req->data);

  baton->error = NULL;

  try {
    std::ostringstream connectionStr;
    if (baton->tns != "") {
      connectionStr << baton->tns;
    } else {
      connectionStr << "//" << baton->hostname << ":" << baton->port << "/" << baton->database;
    }
    baton->connection = baton->environment->create<%- f.cppName %>ion(baton->user, baton->password, connectionStr.str());
  } catch(oracle::occi::SQLException &ex) {
    baton->error = new std::string(ex.getMessage());
  }
}

void <%- obj.name %>::After<%- f.cppName %>(uv_work_t* req, int status) {
  HandleScope scope;
  <%- f.cppName %>Baton* baton = static_cast<<%- f.cppName %>Baton*>(req->data);
  baton->self->Unref();

  Handle<Value> argv[2];
  if(baton->error) {
    argv[0] = Exception::Error(String::New(baton->error->c_str()));
    argv[1] = Undefined();
  } else {
    argv[0] = Undefined();
    Handle<Object> connection = <%- f.cppName %>ion::constructorTemplate->GetFunction()->NewInstance();
    (node::ObjectWrap::Unwrap<<%- f.cppName %>ion>(connection))->set<%- f.cppName %>ion(baton->self->m_environment, baton->connection);
    argv[1] = connection;
  }

  baton->callback->Call(Context::GetCurrent()->Global(), 2, argv);

  delete baton;
}

Handle<Value> <%- obj.name %>::<%- f.cppName %>Sync(const Arguments& args) {
  HandleScope scope;
  REQ_OBJECT_ARG(0, options);

  <%- obj.name %>* self = ObjectWrap::Unwrap<<%- obj.name %>>(args.This());
  <%- f.cppName %>Baton baton(self, self->m_environment, NULL);

  OBJ_GET_STRING(options, "hostname", baton.hostname);
  OBJ_GET_STRING(options, "user", baton.user);
  OBJ_GET_STRING(options, "password", baton.password);
  OBJ_GET_STRING(options, "database", baton.database);
  OBJ_GET_NUMBER(options, "port", baton.port, 1521);

  try {
    std::ostringstream connectionStr;
    connectionStr << "//" << baton.hostname << ":" << baton.port << "/" << baton.database;
    baton.connection = baton.environment->create<%- f.cppName %>ion(baton.user, baton.password, connectionStr.str());
  } catch(oracle::occi::SQLException &ex) {
    baton.error = new std::string(ex.getMessage());
    return scope.Close(ThrowException(Exception::Error(String::New(baton.error->c_str()))));
  } catch (const std::exception& ex) {
    return scope.Close(ThrowException(Exception::Error(String::New(ex.what()))));
  }

  Handle<Object> connection = <%- f.cppName %>ion::constructorTemplate->GetFunction()->NewInstance();
      (node::ObjectWrap::Unwrap<<%- f.cppName %>ion>(connection))->set<%- f.cppName %>ion(baton.self->m_environment, baton.connection);

  return scope.Close(connection);

}
