#include <v8.h>
#include <node.h>
#include "<%- obj.name.toLowerCase() %>.h"

using namespace v8;

<%- obj.name %>::<%- obj.name %>() {};
<%- obj.name %>::~<%- obj.name %>() {};

void <%- obj.name %>::Init(Handle<Object> target) {
  // Prepare constructor template
  Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
  tpl->SetClassName(String::NewSymbol("<%- obj.name %>"));
  tpl->InstanceTemplate()->SetInternalFieldCount(1);

  // Prototype
  <% obj.functions.forEach(function(f) { %>
  tpl->PrototypeTemplate()->Set(String::NewSymbol("<%- f.name %>"),
      FunctionTemplate::New(<%- f.cppName %>)->GetFunction());
  <% }); %>

  constructor = Persistent<Function>::New(tpl->GetFunction());
  target->Set(String::NewSymbol("<%- obj.name %>"), constructor);
}

Handle<Value> <%- obj.name %>::New(const Arguments& args) {
  HandleScope scope;

  <%- obj.name %>* obj = new <%- obj.name %>();

  // ----
  //
  // ----

  obj->Wrap(args.This());

  return args.This();
}

/*
Handle<Value> <%- obj.name %>::NewInstance(const Arguments& args) {
  HandleScope scope;

  const unsigned argc = 1;
  Handle<Value> argv[argc] = { args[0] };
  Local<Object> instance = constructor->NewInstance(argc, argv);

  return scope.Close(instance);
}
*/

<% obj.functions.forEach(function(f) { %>
Handle<Value> <%- obj.name %>::<%- f.cppName %>(const Arguments& args) {
  HandleScope scope;

  <%- obj.name %>* obj = ObjectWrap::Unwrap<<%- obj.name %>>(args.This());

  <% f.args.forEach(function(arg, i) { %>
    REQ_<%- arg.type.toUpperCase() %>_ARG(<%- i %>, <%- arg.name || 'arg'+i %>)
  <% }); %>

  <% if(f.async) {
    var argNames = f.args.map(function(arg, i) {
        return arg.name || 'arg'+i;
    }).join(',');
  %>
  <%- f.cppName %>Baton* baton = new <%- f.cppName %>Baton(<%- argNames %>);
  uv_work_t* req = new uv_work_t();
  req->data = baton;
  uv_queue_work(uv_default_loop(), req, <%- f.cppName %>Async, (uv_after_work_cb)After<%- f.cppName %>Async);
  <% } %>

  return scope.Close(Undefined());
}

<% if(f.async) { %>
void <%- obj.name %>::<%- f.cppName %>Async(uv_work_t* req) {
  <%- f.cppName %>Baton* baton = static_cast<<%- f.cppName %>Baton*>(req->data);

  try {
    // --------
    // Do the work here
    // --------
  } catch (const std::exception& ex) {
    baton->error = new std::string(ex.what());
  }
}

void <%- obj.name %>::After<%- f.cppName %>Async(uv_work_t* req, int status) {
  HandleScope scope;
  <%- f.cppName %>Baton* baton = static_cast<<%- f.cppName %>Baton*>(req->data);

  Handle<Value> argv[2];
  if(baton->error) {
    argv[0] = Exception::Error(String::New(baton->error->c_str()));
    argv[1] = Undefined();
  } else {
    argv[0] = Undefined();
    Handle<Object> result;
    argv[1] = result;
  }

  baton->callback->Call(Context::GetCurrent()->Global(), 2, argv);

  delete baton;

}

<%- f.cppName %>Baton::<%- f.cppName %>Baton(Handle<Function>* callback) {
  if(callback != NULL) {
    this->callback = Persistent<Function>::New(*callback);
  } else {
    this->callback = Persistent<Function>();
  }
}

<%- f.cppName %>Baton::~<%- f.cppName %>Baton() {
  callback.Dispose();
  if(error) {
    delete error;
  }
}
<% } %>

<% }); %>